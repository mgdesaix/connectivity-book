[["index.html", "Creating Migratory Networks in R Chapter 1 Introduction 1.1 Installation", " Creating Migratory Networks in R Matt DeSaix 2021-12-20 Chapter 1 Introduction This text outlines how to create migratory networks using the R package MuSpTest (We need a name!). The creation of the migratory networks is broken into three main parts: Delineating breeding nodes Delineating wintering nodes Create migratory network 1.1 Installation You can install the development version of MuSpTest from GitHub with: # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;mgdesaix/MuSpTest&quot;, auth_token = &quot;xxx&quot;) Note: The auth_token = specifies my personal access token to allow the download because it is currently a private repository. Replace “xxx” with the token until we make the repository public. "],["breeding.html", "Chapter 2 Breeding nodes 2.1 ebirdst 2.2 Seasonal abundance 2.3 Generating seasonal polygons 2.4 Creating the genoscape 2.5 Genoscape polygons", " Chapter 2 Breeding nodes Breeding nodes are delineated by the genetically distinct populations on the breeding grounds. In this example, we’ll show how to use eBird Status and Trends data to specify the breeding range and then use genetic data from admixture analyses to specify the spatial extent of the breeding nodes. 2.1 ebirdst In the migratory network analyses, the ebirdst abundance data is used to delineate the different stages of the annual cycle. The MuSpTest package provides code for these first sections that function as a wrapper for the ebirdst package to streamline the process. If you would like to know more about the underlying ebirdst code and analyses, check out the excellent tutorial by Strimas-Mackey, Auer, and Fink. Prior to doing anything with eBird Status and Trends data, you will need to download the ebirdst package, and then get access to the data. To download the package: # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;CornellLabofOrnithology/ebirdst&quot;) Then, get access to ebirdst data at https://ebird.org/st/request. You will receive a key to download ebirdst data and you can enter that key in R: ebirdst::set_ebirdst_access_key(&quot;XXXXX&quot;) where \"XXXXX\" is the key. The primary packages for this vignette are: library(MuSpTest) library(sf) library(terra) library(tidyverse) library(ebirdst) library(rnaturalearth) 2.2 Seasonal abundance The first function, get_ebirdst_abd_season(), downloads species data and creates a multi-layered raster of seasonal abundance data (nonbreeding, prebreeding migration, breeding, and postbreeding migration). The function currently takes two inputs, species and path. ebirdst data download is based on the six-letter species code, thus, we use the same naming system. You can find the specific codes with the get_species function from the ebirdst package. Specify the species of interest for get_ebirdst_abd_season() with species. Below is an example for downloading data for the Common Yellowthroat and creating the seasonal abundance raster stack. # This can take a while depending on the species (5-10 min.) abd_season &lt;- get_ebirdst_abd_season(species = &quot;comyel&quot;) 2.3 Generating seasonal polygons Using the previously created seasonal abundance rasters, we will convert them to polygons of the range. The details can be found in the ebirdst tutorial, but the gist of it is that we’ll distinguish non-zero abundance from non-predicted areas, and delineate nice smooth ranges for the different stages. We also need land extent data. We will get land data from the rnaturalearth package using the following code. Depending on the organism’s range, you will need to filter continent to the appropriate region. Here, we want both North and South America. ne_scale &lt;- 50 # land polygon ne_land &lt;- rnaturalearth::ne_countries(scale = ne_scale, returnclass = &quot;sf&quot;) %&gt;% dplyr::filter(continent %in% c(&quot;North America&quot;, &quot;South America&quot;)) %&gt;% sf::st_set_precision(1e6) %&gt;% sf::st_union() %&gt;% sf::st_geometry() ne_land_proj &lt;- sf::st_transform(ne_land, crs = sf::st_crs(abd_season)) Now we have all the input data we need to get the polygons of the range. The function range_smooth() in the MuSpTest package takes care of this. In the process of smoothing the polygon, small regions are dropped and holes in the polygon filled in based on the size (\\(km^2\\)) specified with the smooth_area parameter. Below it is set at 1000 \\(km^2\\) (e.g. a 31.6 km * 31.6 km square), but you may want to increase or decrease depending on the organism. # this fuction can take a while (~10 min.) comyel_range_smooth &lt;- range_smooth(abd_season = abd_season, ne_land = ne_land_proj, smooth_area = 1000, split_migration = FALSE, show_yearround = FALSE) Extracting a single polygon of a portion of the range is simple and quick! Here’s an example of getting the breeding season range from the range_smooth() output. comyel_breed_smooth &lt;- dplyr::filter(comyel_range_smooth, season == &quot;breeding&quot;) %&gt;% sf::st_transform(crs = 4326) sf::st_write(comyel_breed_smooth, dsn = &#39;./comyel/shapefiles&#39;, layer = &quot;comyel_breed_smooth&quot;, driver = &quot;ESRI Shapefile&quot;) 2.4 Creating the genoscape This is modified from Eric Anderson’s Github project that uses a matrix of individual Q-values to create a rasters of genetically distinct clusters - the genoscape. If you want to learn the ins and outs of making a beautiful genoscape map, check out Eric’s awesome tutorial. We will use the breeding polygon created in the previous step to specify the breeding range for the genoscape. The input data we need are: Individual Q-value matrix Lat/lon matrix of individual Breeding range polygon The comyel_assignment data set provides admixture results (Q-values) of five genotype clusters for Common Yellowthroat (cite a coye paper) and metadata for the sampled individuals. Q_matrix &lt;- MuSpTest::comyel_assignment %&gt;% dplyr::select(CA, Midwest, NewEngland, West, Southwest) %&gt;% as.matrix() long_lat_matrix &lt;- MuSpTest::comyel_assignment %&gt;% dplyr::select(Long, Lat) %&gt;% as.matrix() cluster_colors &lt;- c( CA = &quot;#CC0000&quot;, Midwest = &quot;#3399FF&quot;, NewEngland = &quot;#9933CC&quot;, West = &quot;#009933&quot;, Southwest = &quot;#FF6600&quot;) We will use a modified version of the tess3r package to create the genoscape rasters. # remotes::install_github(&quot;eriqande/TESS3_encho_sen&quot;) genoscape_brick &lt;- tess3r::tess3Q_map_rasters( x = Q_matrix, coord = long_lat_matrix, map.polygon = breed_smooth, window = terra::ext(breed_smooth)[1:4], resolution = c(300,300), # if you want more cells in your raster, set higher col.palette = tess3r::CreatePalette(cluster_colors, length(cluster_colors)), method = &quot;map.max&quot;, interpol = tess3r::FieldsKrigModel(10), main = &quot;Ancestry coefficients&quot;, xlab = &quot;Longitude&quot;, ylab = &quot;Latitude&quot;, cex = .4 ) names(genoscape_brick) &lt;- colnames(Q_matrix) out.files &lt;- paste0(&quot;./comyel/genoscape/comyel_genoscape_cluster_&quot;, names(genoscape_brick), &quot;.tif&quot;) terra::writeRaster(terra::rast(genoscape_brick), filename = out.files) 2.5 Genoscape polygons Using the genoscape rasters we will convert them to polygons, using the handy scape_to_shape() function. The prob_threshold parameter specifies the value to determine if a raster cell is included in the polygon for that genoscape. This value should be customized for different species to check for overlap of genoscape polygons, which is not desirable. Setting too high of a threshold will create very small breeding nodes, while too low of a threshold will result in large, overlapping breeding nodes. genoscape_files &lt;- list.files(&quot;./comyel/genoscape&quot;, full.names = T, pattern = &quot;*.tif&quot;) genoscape_raster_stack &lt;- terra::rast(genoscape_files) genoscape_polygon_sf &lt;- scape_to_shape(x = genoscape_raster_stack, prob_threshold = 0.5) Check out the polygons ggplot() + geom_sf(data = genoscape_polygon_sf,alpha = 0.75, aes(fill = Cluster)) + scale_fill_manual(values = cluster_colors) Check which polygons are overlapping. Each row of the output provides a pair of overlapping polygons (if there are any). check_genoscape_overlap(genoscape_polygon_sf) ## [,1] [,2] ## [1,] &quot;CA&quot; &quot;West&quot; ## [2,] &quot;Midwest&quot; &quot;NewEngland&quot; ## [3,] &quot;Midwest&quot; &quot;West&quot; "],["wintering.html", "Chapter 3 Wintering nodes 3.1 Subsetting winter ecoregions 3.2 Snap points 3.3 Finalize wintering nodes", " Chapter 3 Wintering nodes For the migratory networks, we will use ecoregions to define the nonbreeding nodes. However, other nonbreeding nodes could be defined by the user instead. If you already have polygons defining your nonbreeding of nodes interest, then move along to … 3.1 Subsetting winter ecoregions The ecoregion data is provided by [provide link]. The ecoregions are provided in this this package as ecoregions_simple. We will intersect the ecoregions with the wintering range of the Common Yellowthroat to identify all the ecoregions that overlap with the wintering range. comyel_winter &lt;- comyel_range_smooth %&gt;% dplyr::filter(season == &quot;nonbreeding&quot;) %&gt;% sf::st_transform(crs = 4326) %&gt;% sf::st_intersection(MuSpTest::ecoregions_simple) %&gt;% dplyr::select(Region) 3.2 Snap points Sometimes individuals are not quite within the wintering nodes. Here, we will make sure all sampled individuals get assigned to the nearest ecoregion. winter.coords &lt;- MuSpTest::coye.winter.meta %&gt;% st_as_sf(coords=c(&quot;Long&quot;,&quot;Lat&quot;)) %&gt;% st_cast(&quot;MULTIPOINT&quot;) %&gt;% st_set_crs(4326) new.winter.coords &lt;- snap_points(winter.coords, comyel_winter, 150000) 3.3 Finalize wintering nodes Now that points have been snapped to the appropriate ecoregions, we can further subset all of the ecoregions in which we have actually sampled individuals from. If we haven’t sampled individuals from a region, we can’t use that region as a node in the migratory connectivity network! winter_intersect &lt;- st_intersects(comyel_winter, new.winter.coords, sparse = T) poly_id &lt;- which(unlist(lapply(winter_intersect, function(x) length(x) &gt; 0))) comyel_winter_ecoregions &lt;- comyel_winter[poly_id,] "],["connectivity.html", "Chapter 4 Migratory Network Model 4.1 Specifying relative abundance 4.2 Run network model", " Chapter 4 Migratory Network Model 4.1 Specifying relative abundance To create the network model, we will first specify the relative abundance for each of the nodes (breeding and wintering). This is used to determine the overall importance of the node to the network model. In this example, we will use summarize relative abundance from the seasonal ebirdst rasters we created, but other data could be used as well (for example, habitat suitability from ecological niche models). For the breeding nodes, we will input the breeding range abundance raster, genoscape polygons, and genoscape cluster names into the MuSpTest function get_abundance_stats(). The output will be a data frame of the summarized node suitability. abd_season &lt;- terra::rast(&quot;./comyel/comyel.abd_season.tif&quot;) ## Breeding cluster_names &lt;- genoscape_polygon_sf$Cluster genoscape_polygon_sf &lt;- sf::st_read(&quot;./comyel/genoscape/polygons/comyel_genoscape_polygon_sf.shp&quot;) breeding_abundance_sum &lt;- get_abundance_stats(range_raster = abd_season[[&quot;breeding&quot;]], node_poly = genoscape_polygon_sf, group_names = cluster_names) Similarly for the wintering nodes, we will input the nonbreeding range abundance raster, winter ecoregions, and ecoregion names into the MuSpTest function get_abundance_stats(). ## Nonbreeding comyel_winter_ecoregions &lt;- sf::st_read(&quot;./comyel/winter_regions/comyel_winter_ecoregions.shp&quot;) ecoregion_names &lt;- comyel_winter_ecoregions$Region nonbreeding_abundance_sum &lt;- get_abundance_stats(range_raster = abd_season[[&quot;nonbreeding&quot;]], node_poly = comyel_winter_ecoregions, group_names = ecoregion_names) 4.2 Run network model "],["network-visualization.html", "Chapter 5 Network visualization", " Chapter 5 Network visualization To be created… "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
