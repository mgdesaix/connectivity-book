# Quick start example {#quickstart}

Here, we demonstrate a quick example of how to create a migratory network when the user has all of the data required. To run this tutorial, load the following packages:

```r
library(tidyverse)
library(mignette)
library(rjags)
library(jagsUI)
library(ggnewscale)
```

The data required are:

* Relative abundance matrix for each node
* Assignment matrix of individuals among nodes

We provide an example of these data in `mignette`, with assignment data from 5 populations from the breeding range (WB = Western Boreal, NT = Northern Temperate, ST = Southern Temperate, BR = Basin Rockies, MP = Maritime Provinces) and nonbreeding range (ALM = Atlantic Lowland Mexico, CAR = Caribbean, AONU = Amazon/Orinoco-Northern Uplands, HCA = Highland Central America, LCA = Lowland Central America) of the American Redstart (*Setophaga ruticilla*). The assignment matrix specifies the number of individuals that have been sampled or detected that migrate between different populations (i.e. *connect* the nodes).

```r
mignette::amre_assign
```

```{r, echo=FALSE}
knitr::kable(mignette::amre_assign)
```

Assignment data input into `mignette` needs to follow the above format, where the first column specifies breeding population IDs while subsequent columns are the nonbreeding populations.

We also provide the relative abundance of these populations:

```r
mignette::amre_abundance
```

```{r, echo=FALSE}
knitr::kable(mignette::amre_abundance)
```

The *relative abundance* data needs to follow the above format for input into `mignette` functions, with population IDs (same names as in the *assignment* file) in the first column and relative abundance values in the second column. Column names can follow any naming convention when inputting these data into `mignette`.

For the following functions, we specify the order of the populations we are using for the model. Here, we are just ordering populations geographically by longitude to facilitate straightforward interpretation of the output.

```{r}
bnode_names <- c("WB", "BR", "NT", "ST", "MP")
wnode_names <- c("ALM", "LCA", "HCA", "CAR", "AONU")
```

For the American Redstart migratory network, we use `model = 1` from `mignette` which specifies that nonbreeding nodes are “encountered” and breeding nodes are “recovered” (i.e., inferred). This output saves the model as `amre.genetic.model_1.txt`. Below we specify `parallel = TRUE` to run MCMC on multiple cores and use the remaining defaults described previously CHANGE LINK. This step is computationally intensive and takes ~2 minutes to run on a 2023 MacBook Pro with an Apple M2 Pro chip.


```r
network_model <- run_network_model(abundance = mignette::amre_abundance,
                       	nb2br_assign = mignette::amre_assign,
                       	bnode_names = bnode_names,
                       	wnode_names = wnode_names,
                       	model = 1, 
                       	base_filename = "amre.genetic",
                       	parallel = TRUE)
```

The `run_network_model()` function outputs a list object with two components. The first component of the output is `network_model$conn` which provides a formatted data frame (i.e., breeding nodes in first column, remaining columns have nonbreeding node names) of the modeled connectivity results. Each value in the connectivity matrix indicates the overall importance of a particular migratory connection. These values are interpreted as the proportion of individuals that migrate between the corresponding populations, as such all of the values in the connectivity matrix sum to one. 

```r
network_model$conn
```

```{r, echo=FALSE}
conn_ex <- mignette::amre_conn
rownames(conn_ex) <- NULL
conn_ex %>% 
  as_tibble() %>% 
  add_column("Breeding" = bnode_names, .before = 1) %>%
  knitr::kable()
```


The second component is the full output from [`*jagsUI* autojags()`](https://rdrr.io/cran/jagsUI/man/autojags.html) and is accessed by `network_model$jags_out`. Here, the raw connectivity matrix can be accessed:

```r
amre_conn <- network_model$jags_out$mean$conn_g
amre_conn
```

```{r, echo = FALSE}
amre_conn <- mignette::amre_conn
rownames(amre_conn) <- NULL
colnames(amre_conn) <- NULL
knitr::kable(amre_conn)
```

```{r}
amre_net <- net_create(amre_conn,
                        	node.names = list(bnode_names,wnode_names),
                        	connected_tol = 0.02)
#set the display size range for nodes (min and max), default 1-10
amre_net$display_par$node_size_scale<-c(8,25)
#set the display size range for edges (min and max), default 1-10
amre_net$display_par$edge_size_scale<-c(1,5)
# change colors
amre_net$display_par$bnode_colors <- c("#009e73", "#cc79a7", "#56b4e9", "#e69f00", "#7979ff")
amre_net$display_par$wnode_colors <- "grey80"

net_draw(amre_net)
```

In this visualization, node size corresponds to the amount of connectivity with that population and edge size corresponds to the amount of connectivity between the populations. Breeding populations are in the top row, for which we provided custom colors, and nonbreeding populations are in the bottom row.

This sums up the basics of creating and visualizing a migratory network. We encourage users to explore and build upon the visualization tools we provide (e.g. overlay the migratory networks on geographic ranges) - the options are endless, enjoy!

